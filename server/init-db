#!/usr/bin/env bash
set -euo pipefail

# DB management script. Does NOT touch roles. 
# Use --create to
# drop & recreate the DB; when --create is used the one-time `init-user`
# script will be invoked to (re)create users.

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
source "$SCRIPT_DIR/bootstrap-common.sh"

FORCE_RESET=false
while [ "$#" -gt 0 ]; do
  case "$1" in
    --force-reset)
      FORCE_RESET=true; shift;;
    -h|--help)
      echo "Usage: $0 [--force-reset]"; exit 0;;
    *) echo "Unknown arg: $1" >&2; exit 2;;
  esac
done

ensure_command psql
ensure_env_set POSTGRES_USER
ensure_env_set POSTGRES_PASSWORD
ensure_env_set DB_ADMIN_USER
ensure_env_set DB_ADMIN_PASSWORD
ensure_env_set APP_USER
ensure_env_set APP_PASSWORD
ensure_env_set TRAILFOX_DB

if ! wait_for_postgres; then
  echo "Postgres unreachable" >&2
  exit 1
fi

export PGPASSWORD="${POSTGRES_PASSWORD}"

if $FORCE_RESET; then
  echo "-- terminating connections to $TRAILFOX_DB"
  ATTEMPTS=0
  while true; do
    "${PSQL_POSTGRES[@]}" -c \
      "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '$TRAILFOX_DB' AND pid <> pg_backend_pid();" >/dev/null || true

    SESSIONS=$("${PSQL_POSTGRES[@]}" -tAc \
      "SELECT count(*) FROM pg_stat_activity WHERE datname = '$TRAILFOX_DB' AND pid <> pg_backend_pid();")

    if [ "$SESSIONS" = "0" ]; then
      break
    fi
    ATTEMPTS=$((ATTEMPTS + 1))
    if [ "$ATTEMPTS" -ge 5 ]; then
      echo "-- warning: $SESSIONS connections remain after $ATTEMPTS attempts; proceeding to DROP and hope for best"
      break
    fi
    echo "-- $SESSIONS connections still present; retrying in 1s"
    sleep 1
  done

  echo "-- dropping schemas in $TRAILFOX_DB"
  "${PSQL_POSTGRES[@]}" -c "DROP SCHEMA IF EXISTS itinerarius CASCADE;"
  "${PSQL_POSTGRES[@]}" -c "DROP SCHEMA IF EXISTS api CASCADE;"

  # call init-user to (re)create roles
  echo "-- invoking init-user to recreate roles"
  "$SCRIPT_DIR/init-user"
fi

EXISTS_DB=$("${PSQL_POSTGRES[@]}" -tAc "SELECT 1 FROM pg_database WHERE datname='$TRAILFOX_DB';")
if [ "$EXISTS_DB" != "1" ]; then
  echo "-- creating database $TRAILFOX_DB owned by $DB_ADMIN_USER"
  "${PSQL_POSTGRES[@]}" -c "CREATE DATABASE $TRAILFOX_DB OWNER $DB_ADMIN_USER;"
else
  echo "-- database $TRAILFOX_DB exists (leave as-is)"
fi

echo "-- ensuring PostGIS is installed in $TRAILFOX_DB (public schema) as superuser"

PGPASSWORD="${POSTGRES_PASSWORD}" psql -v ON_ERROR_STOP=1 -h "${POSTGRES_HOST}" -p "${POSTGRES_PORT:-5432}" -U "${POSTGRES_USER}" -d "${TRAILFOX_DB}" <<EOSQL
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS postgis_topology;
CREATE EXTENSION IF NOT EXISTS pg_trgm;

CREATE SCHEMA IF NOT EXISTS itinerarius AUTHORIZATION "$DB_ADMIN_USER";
CREATE SCHEMA IF NOT EXISTS api AUTHORIZATION "$DB_ADMIN_USER";

GRANT ALL ON SCHEMA public TO "$DB_ADMIN_USER";

-- RO grants + future objects
GRANT USAGE ON SCHEMA itinerarius TO "$APP_USER";
GRANT USAGE ON SCHEMA api TO "$APP_USER";

-- Current tables/sequences
GRANT SELECT ON ALL TABLES IN SCHEMA itinerarius TO "$APP_USER";
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA itinerarius TO "$APP_USER";
GRANT SELECT ON ALL TABLES IN SCHEMA api TO "$APP_USER";
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA api TO "$APP_USER";

-- Future tables/sequences (admin creates â†’ app RO)
ALTER DEFAULT PRIVILEGES IN SCHEMA itinerarius GRANT SELECT ON TABLES TO "$APP_USER";
ALTER DEFAULT PRIVILEGES IN SCHEMA itinerarius GRANT USAGE, SELECT ON SEQUENCES TO "$APP_USER";
ALTER DEFAULT PRIVILEGES IN SCHEMA api GRANT SELECT ON TABLES TO "$APP_USER";
ALTER DEFAULT PRIVILEGES IN SCHEMA api GRANT USAGE, SELECT ON SEQUENCES TO "$APP_USER";
ALTER ROLE "$APP_USER" SET statement_timeout = '8s';
SELECT postgis_full_version();
EOSQL

echo "-- init-db completed"
